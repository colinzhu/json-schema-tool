/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /gh/nuxodin/jema.js@1.2.0/schema.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const refKey=Symbol("ref"),defaultLocation=window?.location?.href||"http://localhost/";let currentSchema=null,schemaStack=null,dataStack=null;export const AllSchemas=new Map;function loadSchema(e){if(!AllSchemas.has(e)){const t=fetch(e).then((e=>e.json())).then((async t=>{t.$id&&t.$id!==e&&console.warn("Schema id does not match url",t.$id,e),t.$id=e;const r=new Schema(t);return await r.deref(),r}));AllSchemas.set(e,t)}return AllSchemas.get(e)}export class Schema{constructor(e){"object"==typeof e&&(e.$schema??="https://json-schema.org/draft/2020-12/schema"),this.schema=e,this.id=e.$id,this.anchors=new Map([["",this.schema]]),this.dynAnchors=new Map,this.#e(this.schema)}async schemaErrors(){return(await loadSchema(this.schema.$schema)).errors(this.schema)}validate(e){return this.errors(e).next().done}*errors(e){return currentSchema=this,this.schemaStack=schemaStack=[],this.dataStack=dataStack=[],yield*errors(e,this.schema)}#e(e){if(!e.$id||e.$id===this.id){e.$anchor&&!this.anchors.has(e.$anchor)&&this.anchors.set(e.$anchor,e),e.$dynamicAnchor&&!this.dynAnchors.has(e.$dynamicAnchor)&&this.dynAnchors.set(e.$dynamicAnchor,e);for(const t of subSchemas(e))this.#e(t)}}#t(e,t){if(e.$id){const r=new URL(e.$id,t);if(t=e.$id=r.toString(),!AllSchemas.has(r.href)){const t=new Schema(e),n=new Promise((e=>{queueMicrotask((()=>{t.deref(),e(t)}))}));AllSchemas.set(r.href,n)}}for(const r of subSchemas(e))this.#t(r,t)}async deref(){this.#t(this.schema,defaultLocation);const e=this.#r(this.schema);this.foraignSchemas=await promisesAllMap(e),this.#n(this.schema)}#n(e){if(e.$ref&&!e[refKey]){const t=e.$ref,r=this.walk(t);null==r&&console.error("$ref-schema not found",t,e),e[refKey]=r}if(e.$dynamicRef&&!e[refKey]){const t=e.$dynamicRef,r=this.walk(t);null==r&&console.error("$dynamicRef-schema not found",t,e),e[refKey]=r}for(const t of subSchemas(e))this.#n(t)}#r(e,t){e.$id&&(t=e.$id);const r=new Map;if(e.$ref&&!e[refKey]&&"#"!==e.$ref[0]){const n=new URL(e.$ref,t).href.split("#")[0];r.set(n,loadSchema(n))}for(const n of subSchemas(e))this.#r(n,t).forEach(((e,t)=>r.set(t,e)));return r}walk(e,t){if("#"!==e[0]){const{url:t,hash:r}=this.relativeUrl(e),n=this.foraignSchemas.get(t);return n?n.walk(r):void console.warn("foraignSchema not found",t,e)}const[r,...n]=e.substring(1).split("/");let a;if(a=t?.dynamic?this.dynAnchors.get(r):this.anchors.get(r)||this.dynAnchors.get(r),a)return walk(a,n)}relativeUrl(e){const[t,r=""]=new URL(e,this.id).href.split("#");return{url:t,hash:"#"+r}}}function*subSchemas(e){for(const[t,r]of Object.entries(e)){const e=vocabulary[t]?.subSchema;if("object"===e)for(const e of Object.values(r))yield e;if("array"===e)for(const e of r)yield e;!0===e&&(yield r)}}const evaluatedFor=new WeakMap;let stopCollectingEvaluated=!1;function*errors(e,t){if(!1===t)return void(yield schemaError(e,!1,"fails, false-schema at:"));if(!0===t)return;const r=getType(e),n=unevaluatedNames[r];n in t&&(evaluatedFor.has(e)||evaluatedFor.set(e,new Set));for(const n of Object.keys(t)){const a=vocabulary[n];if(!a||a.affects&&a.affects!==r)continue;const s=a?.valid;s&&(schemaStack.push(n),s instanceof GeneratorFunction?yield*s(t[n],e,t):s(t[n],e,t)||(yield schemaError(e,t[n])),schemaStack.pop())}if(typeValidators[r]&&(yield*typeValidators[r](t,e)),n in t){const a=evaluatedFor.get(e);if(a){const s="object"===r?Object.keys(e):e.keys();for(const r of s)a.has(r)||(yield*errors(e[r],t[n]));evaluatedFor.delete(e)}}}const typeValidators={*object(e,t){const r=e.properties,n=e.patternProperties&&Object.entries(e.patternProperties),a=e.additionalProperties;for(const[e,s]of Object.entries(t)){dataStack.push(e);let i=!0;const o=r?.[e];if(null!=o&&(schemaStack.push("properties",e),yield*errors(s,o),schemaStack.pop(),schemaStack.pop(),i=!1),n){schemaStack.push("patternProperties",e);for(const[t,r]of n)new RegExp(t,"u").test(e)&&(yield*errors(s,r),i=!1);schemaStack.pop(),schemaStack.pop()}null!=a&&i&&(schemaStack.push("additionalProperties"),yield*errors(s,a),schemaStack.pop(),i=!1),i||stopCollectingEvaluated||evaluatedFor.get(t)?.add(e),dataStack.pop()}},*array(e,t){let r=0;for(const[n,a]of t.entries()){dataStack.push(n);let s=!0;if(null!=e.prefixItems?.[n])yield*errors(a,e.prefixItems[n]),s=!1;else if(null!=e.items){for(const r of errors(a,e.items))evaluatedFor.get(t)?.clear(),yield r;s=!1}if(null!=e.contains){errors(a,e.contains).next().done&&(r++,s=!1)}s||stopCollectingEvaluated||evaluatedFor.get(t)?.add(n),dataStack.pop()}if(null!=e.contains){const t=e.minContains??1,n=e.maxContains??1/0;r<t&&(yield'Array contains too few items that match "contains"'),r>n&&(yield'Array contains too many items that match "contains"')}}},vocabulary={$schema:{},$vocabulary:{},$id:{},$anchor:{},$dynamicAnchor:{},$ref:{*valid(e,t,r){return null==r[refKey]&&console.error("dynamicRef: no schema found, deref() called?",e),yield*errors(t,r[refKey])}},$dynamicRef:{*valid(e,t,r){const n=currentSchema.walk(e,{dynamic:!0})||r[refKey];return null==n&&console.error("dynamicRef: no schema found, deref() called?",e,currentSchema),yield*errors(t,n)}},$defs:{subSchema:"object"},allOf:{*valid(e,t){for(const[r,n]of e.entries())schemaStack.push(r),yield*errors(t,n),schemaStack.pop()},subSchema:"array"},anyOf:{valid(e,t){const r=evaluatedFor.has(t);let n=!1;for(const a of e){if(errors(t,a).next().done){if(!r)return!0;n=!0}}return n},subSchema:"array"},oneOf:{valid(e,t){let r=0;for(const n of e)if(r+=errors(t,n).next().done?1:0,r>1)return!1;return 1===r},subSchema:"array"},not:{valid(e,t){stopCollectingEvaluated=!0;const r=errors(t,e).next().done;return schemaStack.pop(),stopCollectingEvaluated=!1,!r},subSchema:!0},if:{*valid(e,t,r){const n=errors(t,e).next().done;schemaStack.pop(),n?(schemaStack.push("then"),null!=r.then&&(yield*errors(t,r.then))):(schemaStack.push("else"),null!=r.else&&(yield*errors(t,r.else))),schemaStack.pop()},subSchema:!0},then:{subSchema:!0},else:{subSchema:!0},type:{valid(e,t){if(Array.isArray(e)){for(const r of e)if(vocabulary.type.valid(r,t))return!0;return}const r=getType(t);return r===e||(!("integer"!==e||"number"!==r||!Number.isInteger(t))||void 0)}},enum:{valid(e,t){for(const r of e)if(deepEqual(r,t))return!0}},const:{valid:(e,t)=>deepEqual(e,t)},multipleOf:{valid(e,t){const r=t/e;return Number.isFinite(r)&&r*e==Math.round(r)*e},affects:"number"},maximum:{valid:(e,t)=>t<=e,affects:"number"},exclusiveMaximum:{valid:(e,t)=>t<e,affects:"number"},minimum:{valid:(e,t)=>t>=e,affects:"number"},exclusiveMinimum:{valid:(e,t)=>t>e,affects:"number"},maxLength:{valid:(e,t)=>[...t].length<=e,affects:"string"},minLength:{valid:(e,t)=>[...t].length>=e,affects:"string"},pattern:{valid:(e,t)=>new RegExp(e,"u").test(t),affects:"string"},format:{valid:(e,t)=>!0,affects:"string"},maxItems:{valid:(e,t)=>t.length<=e,affects:"array"},minItems:{valid:(e,t)=>t.length>=e,affects:"array"},uniqueItems:{valid:(e,t)=>{if(!e)return!0;const r=new Set;for(const e of t){const t=uniqueValueIgnoreKeyOrder(e);if(r.has(t))return!1;r.add(t)}return!0},affects:"array"},items:{subSchema:!0},additionalItems:{subSchema:!0},contains:{subSchema:!0},prefixItems:{subSchema:"array"},unevaluatedItems:{subSchema:!0},properties:{subSchema:"object"},additionalProperties:{subSchema:!0},unevaluatedProperties:{subSchema:!0},patternProperties:{subSchema:!0},maxProperties:{valid:(e,t)=>Object.keys(t).length<=e,affects:"object"},minProperties:{valid:(e,t)=>Object.keys(t).length>=e,affects:"object"},required:{*valid(e,t){for(const[r,n]of e.entries())Object.hasOwn(t,n)||(schemaStack.push(r),yield schemaError(t,n,"missing required property"),schemaStack.pop())},affects:"object",subSchema:!0},dependentRequired:{valid:(e,t)=>{for(const[r,n]of Object.entries(e))if(Object.hasOwn(t,r))for(const e of n)if(!Object.hasOwn(t,e))return!1;return!0},affects:"object"},dependentSchemas:{*valid(e,t){for(const[r,n]of Object.entries(e))Object.hasOwn(t,r)&&(yield*errors(t,n))},affects:"object",subSchema:!0},dependencies:{*valid(e,t){for(const[r,n]of Object.entries(e))if(Object.hasOwn(t,r))if(Array.isArray(n))for(const e of n)Object.hasOwn(t,e)||(yield schemaError(t,e,"missing required property"));else yield*errors(t,n)}},propertyNames:{*valid(e,t){for(const r of Object.keys(t))yield*errors(r,e)},affects:"object",subSchema:!0}};function schemaError(e,t,r="does not match"){return{message:`${Array.isArray(e)?"array":"object"==typeof e?"object":'"'+e+'"'} ${r} ${schemaStack.at(-1)}:${t}`,value:e,schemaValue:t,schemaStack:[...schemaStack],dataStack:[...dataStack]}}function getType(e){if(null==e)return"null";const t=typeof e;return"number"!==t||isFinite(e)?"object"===t&&Array.isArray(e)?"array":t:"not supported"}const unevaluatedNames={object:"unevaluatedProperties",array:"unevaluatedItems"};function validDate(e){const t=e.match(/^(\d{4})-(\d{2})-(\d{2})$/);if(!t)return!1;const[r,n,a]=t.slice(1);if(n>12)return!1;if(a>31)return!1;if(a>28){if(a>new Date(r,n,0).getDate())return!1}return!0}function validTime(e){const t=e.match(/^(\d{2}):(\d{2}):(\d{2})(?:\.\d+)?(?:Z|([\+-]\d{2}):(\d{2}))$/i);if(!t)return!1;const[r,n,a,s,i]=t.slice(1);if(r>23)return!1;if(n>59)return!1;if(a>60)return!1;if(null!=s){if(s>23)return!1;if(s<-23)return!1;if(void 0===i)return!1;if(i>59)return!1}if("60"==a){const e=1*n-(i||0),t=1*r-(s||0);if(59!==e&&-1!==e)return!1;if(23!==t&&0!==t)return!1}return!0}function validDateTime(e){const[t,r]=e.split(/T/i);return!!validDate(t)&&!!validTime(r)}function isValidHostname(e){if(!e||e.length>255)return!1;if(!/^[a-zA-Z0-9\-.]+$/.test(e))return!1;const t=e.split(".");for(const e of t){if(!e||e.length>63)return!1;if("-"===e[0]||"-"===e.at(-1))return!1}return!0}function isValidIdnHostname(e){try{new URL("http://"+e)}catch{return!1}for(let t of e.split(".")){if(t=t.toLowerCase(),t.length>63)return!1;if("--"===t.substring(2,4))return!1;if(t.startsWith("-")||t.endsWith("-"))return!1;if(t.match(/(?<!.)\u05F4/))return!1;if(t.match(/(?<![\p{Script=Hebrew}])\u05F3/u))return!1;if(t.match(/\u0375(?![\p{Script=Greek}])/u))return!1;if(t.includes("〮"))return!1;if((t.includes("・")||t.includes("·"))&&!/[\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Han}]/u.test(t))return!1}return!0}function isValidIPv4(e){return/^((?!0\d)\d{1,3}\.){3}(?!0\d)\d{1,3}$/.test(e)&&e.split(".").every((e=>e>=0&&e<=255))}function isValidIPv6(e){try{return new URL(`http://[${e}]`),!0}catch{return!1}}function isValidEmail(e,t){const r=e.lastIndexOf("@"),n=e.substring(0,r),a=e.substring(r+1);if(""===n)return!1;if("["===a[0]&&"]"===a.at(-1)){if(a.startsWith("[IPv6:")){if(!isValidIPv6(a.slice(6,-1)))return!1}else if(!isValidIPv4(a.slice(1,-1)))return!1}else if(t){if(!isValidIdnHostname(a))return!1}else if(!isValidHostname(a))return!1;return/^(?!\.)("([^"\r\\]|\\["\r\\])*"|([-a-z0-9!#$%&'*+/=?^_`{|}~]|(?<!\.)\.)*)(?<!\.)$/.test(n)}function parseDuration(e){const[t,r]=e.split("T"),n=t.match(/^P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?$/);if(!n)return null;const[,a,s,i,o]=n;if(null!=i&&(null!=a||null!=s||null!=o))return null;if(""===r)return null;const c=r?.match(/^(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/)??[],[,l,u,f]=c;return null==a&&null==s&&null==i&&null==o&&null==l&&null==u&&null==f?null:{years:a,months:s,weeks:i,days:o,hours:l,minutes:u,seconds:f}}function walk(e,t){let r=e;for(let n of t){if(n=n.replace(/~1/g,"/").replace(/~0/g,"~").replace(/%25/g,"%").replace(/%22/g,'"'),!(n in r))return void console.warn(`path '${t.join("/")}' not found in schema`,e);r=r[n]}return r}function deepEqual(e,t){if(e===t)return!0;if(null==e&&null!=t)return!1;if(null!=e&&null==t)return!1;if("object"==typeof e&&"object"==typeof t){if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(!deepEqual(e[r],t[r]))return!1;return!0}{const r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(const n of r)if(!deepEqual(e[n],t[n]))return!1;return!0}}return!1}async function promisesAllMap(e){const t=await Promise.all(e.values()),r=new Map;for(const[n]of e)r.set(n,t.shift());return r}function uniqueValueIgnoreKeyOrder(e){if(null==e||"object"!=typeof e)return e;const t=deepCopyObjectAndOrderKeys(e);return"hopeNoOneWillEverUseString"+JSON.stringify(t)}function deepCopyObjectAndOrderKeys(e){if(null==e||"object"!=typeof e)return e;if(Array.isArray(e))return e.map(deepCopyObjectAndOrderKeys);const t={};for(const r of Object.keys(e).sort())t[r]=deepCopyObjectAndOrderKeys(e[r]);return t}const GeneratorFunction=function*(){}.constructor;
//# sourceMappingURL=/sm/557583675bf5ad5e324597b3a02a2da43f2dd84c53244f93490e4597ab03ab35.map